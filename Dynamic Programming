ğğ®ğ¦ğ›ğğ« ğ¨ğŸ ğ”ğ§ğ¢ğªğ®ğ ğğšğ­ğ¡ğ¬
*Given a A X B matrix with your initial position at the top-left cell, find the number of possible unique paths to reach the bottom-right cell of the matrix from the initial position.
Note: Possible moves can be either down or right at any point in time, i.e., we can move to matrix[i+1][j] or matrix[i][j+1] from matrix[i][j].*

Sol :
int ans(int a,int b){
  int dp[a][b];
  for(int i=0;i<a;i++){
    dp[i][0]=1;
  }
  for(int i=0;i<b;i++){
    dp[0][i]=1;
  }
  for(int i=1;i<a;i++){
    for(int j=1;j<b;j++){
        dp[i][j]=dp[i-1][j]+dp[i][j-1];
  }}
  return dp[a-1][b-1];
}

ğ‚ğ¨ğ®ğ§ğ­ ğ°ğšğ²ğ¬ ğ­ğ¨ ğ«ğğšğœğ¡ ğ­ğ¡ğ ğ§â€™ğ­ğ¡ ğ¬ğ­ğšğ¢ğ«:
int countWaysUtil(int n, int m)
{
    int res[n];
    res[0] = 1;
    res[1] = 1;
    for(int i = 2; i < n; i++)
    {
       res[i] = 0;
       for(int j = 1; j <= m && j <= i; j++)
          res[i] += res[i - j];
    }
    return res[n - 1];
}
int countWays(int s, int m)
{
    return countWaysUtil(s + 1, m);
}

ğŒğšğ±ğ¢ğ¦ğ¢ğ³ğ ğ“ğ¡ğ ğ‚ğ®ğ­ ğ’ğğ ğ¦ğğ§ğ­ğ¬:
int maximizeTheCuts(int n, int x, int y, int z)
    {
        if(n==0) return 0;
        int one = (n-x)>0?maximizeTheCuts(n-x,x,y,z):0;
        int two = (n-y)>0?maximizeTheCuts(n-y,x,y,z):0;
        int three = (n-z)>0?maximizeTheCuts(n-z,x,y,z):0;
        return 1+max(one,max(two,three));
    }

ğŒğ¢ğ§ğ¢ğ¦ğ®ğ¦ ğ§ğ®ğ¦ğ›ğğ« ğ¨ğŸ ğ£ğ®ğ¦ğ©ğ¬:
int minJumps(int arr[], int n){
        if(arr[0]==0 || n==0) return -1;
        int dp[n];
        for(int i=0;i<n;i++){
            dp[i]=INT_MAX;
        }
        dp[0]=0;
        for(int i=1;i<n;i++){
            for(int j=0;j<i;j++){
                if(i<=j+arr[j] && dp[i]!=INT_MAX){
                    dp[i]=min(dp[i],dp[j]+1);
                }
            }  
        }
        return dp[n-1];
    }
    
  ğ“ğ¨ğ­ğšğ¥ ğƒğğœğ¨ğğ¢ğ§ğ  ğŒğğ¬ğ¬ğšğ ğğ¬:
  int countDecodingDP(char *digits, int n)
{
    int count[n+1];
    count[0] = 1;
    count[1] = 1;
    if(digits[0]=='0') 
         return 0;
    for (int i = 2; i <= n; i++)
    {
        count[i] = 0;
        if (digits[i-1] > '0')
            count[i] = count[i-1];
        if (digits[i-2] == '1' ||
              (digits[i-2] == '2' && digits[i-1] < '7') )
            count[i] += count[i-2];
    }
    return count[n];
}

ğ‹ğ¨ğ§ğ ğğ¬ğ­ ğ‚ğ¨ğ¦ğ¦ğ¨ğ§ ğ’ğ®ğ›ğ¬ğğªğ®ğğ§ğœğ:
int lcs(int m, int n, string s1, string s2)
    {
       int L[m + 1][n + 1]; 
       int i, j; 
       for (i = 0; i <= m; i++) 
        { 
        for (j = 0; j <= n; j++) 
        { 
        if (i == 0 || j == 0) 
            L[i][j] = 0; 
        else if (s1[i - 1] == s2[j - 1]) 
            L[i][j] = L[i - 1][j - 1] + 1; 
        else
            L[i][j] = max(L[i - 1][j], L[i][j - 1]); 
        } 
    }
    return L[m][n]; 
    }
    
ğ‚ğ¨ğ§ğ¬ğğœğ®ğ­ğ¢ğ¯ğ ğŸ'ğ¬ ğ§ğ¨ğ­ ğšğ¥ğ¥ğ¨ğ°ğğ:
ll countStrings(int n) {
	    ll a[n];
	    ll b[n];
	    a[0]=1;
	    b[0]=1;
	    for(int i=1;i<n;i++){
	        a[i]=a[i-1]+b[i-1];
	        b[i]=b[i-1];
	    }
	    return a[n-1]+b[n-1];
	}
  
ğ„ğğ¢ğ­ ğƒğ¢ğ¬ğ­ğšğ§ğœğ:
int editDistance(string a,string b,int n,int m){
    int dp[n+1][m+1];
    for(int i=0;i<n+1;i++){
    for(int j=0;j<m+1;j++){
      if(n==0){
        dp[i][j] = j;
      }
      else if(m==0){
        dp[i][j]=i;
      }
      else if(a[i-1]==b[j-1]){
        dp[i][j] = dp[i-1][j-1];
      }
      else{
        dp[i][j] = 1 + + min(dp[i][j - 1],dp[i - 1][j], dp[i - 1][j - 1]);
      }     
    }
    }
    return dp[n][m];
}
