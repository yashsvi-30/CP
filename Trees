ğŒğ¢ğ«ğ«ğ¨ğ« ğ“ğ«ğğ:
void mirrorTree(struct Node *root){
  if(root==NULL) return;
  mirrorTree(root->left);
  mirrorTree(root->right);
  struct Node* temp = root->left;
  root->left = root->right;
  root->right = temp;
}


ğğ¨ğ¬ğ­ğ¨ğ«ğğğ« ğ“ğ«ğšğ¯ğğ«ğ¬ğšğ¥:
void postorder(struct Node* tree){
  if(root==NULL) return;
  postorder(root->left);
  postorder(root->right);
  cout<<root->data<<endl;
}

ğğ«ğğ¨ğ«ğğğ« ğ“ğ«ğšğ¯ğğ«ğ¬ğšğ¥:
void preorder(struct Node* root){
  if(root==NULL)return;
  preorder(root->left);
  cout<<root->data;
  preorder(root->right);
}

ğ‚ğ¡ğğœğ¤ ğŸğ¨ğ« ğğ’ğ“:
bool isBST(Node* node, int min,int max){
  if(node==NULL) return true;
  if(node->data < min || node->data > max) return false;
  return isBST(node->left,min,node->data-1) && isBST(node->right,node->data+1,max);
}
bool BST(Node* node){
int min = INT_MIN;
int max = INT_MAX;
 return isBST(node,min,max);
}

ğ‹ğğ¯ğğ¥ ğ¨ğ«ğğğ« ğ­ğ«ğšğ¯ğğ«ğ¬ğšğ¥ ğ¢ğ§ ğ¬ğ©ğ¢ğ«ğšğ¥ ğŸğ¨ğ«ğ¦:
void printSpiral(Node *root)
{
    if(root==NULL) return;
    int level=0;
    queue<Node* > q;
    q.push(root);
    while(!q.empty()){
        level++;
        vector<int> v;
        int s = q.size();
        while(s--){
            Node* temp = q.front();
            if(temp->left) q.push(temp->left);
            if(temp->right) q.push(temp->right);
            q.pop();
            v.push_back(temp->data);
        }
        if(level%2==1){
            reverse(v.begin(),v.end());
        }
        for(int i=0;i<v.size();i++){
                cout<<v[i]<<" ";
            }
    }
}
    
ğ“ğ«ğšğ§ğ¬ğŸğ¨ğ«ğ¦ ğ­ğ¨ ğ’ğ®ğ¦ ğ“ğ«ğğ:
int toSumTree(Node *Node)
    {
      if(Node==NULL) return 0;
      int old_value = Node->data;
      Node->data = toSumTree(Node->left)+toSumTree(Node->right);
      return Node->data + old_value;
    }

ğ‚ğ¡ğğœğ¤ ğŸğ¨ğ« ğğšğ¥ğšğ§ğœğğ ğ“ğ«ğğ:
int height(Node* root){
    if(root==NULL) return 0;
    int lheight = height(root->left);
    int rheight = height(root->right);
    return max(lheight,rheight)+1;
}
bool isBalanced(Node *root)
{
    if(root==NULL) return true;
    int l = height(root->left);
    int r = height(root->right);
    if(abs(l-r)<=1 && isBalanced(root->left) && isBalanced(root->right)){
        return true;
    }
    return false;
}

ğ™ğ¢ğ ğ™ğšğ  ğ“ğ«ğğ ğ“ğ«ğšğ¯ğğ«ğ¬ğšğ¥:
vector <int> zigZagTraversal(Node* root)
{
	vector<int> ans;
	if(root==NULL){
	    return ans;
	}
	queue<Node*> q;
	int level=0;
	q.push(root);
	while(!q.empty()){
	    int s = q.size();
	    vector<int> v;
	    while(s--){
	        Node* temp = q.front();
	        q.pop();
	        if(temp->left) {
	            q.push(temp->left);
	        }
	        if(temp->right){
	            q.push(temp->right);
	        }
	        v.push_back(temp->data);
	    }
	    if(level%2==0){
	        for(int i=0;i<v.size();i++){
	            ans.push_back(v[i]);
	        }
	    }
	    else{
	        for(int i=v.size()-1;i>=0;i--){
	            ans.push_back(v[i]);
	        }
	    }
	    level++;
	}
	return ans;
}

