𝐌𝐢𝐫𝐫𝐨𝐫 𝐓𝐫𝐞𝐞:
void mirrorTree(struct Node *root){
  if(root==NULL) return;
  mirrorTree(root->left);
  mirrorTree(root->right);
  struct Node* temp = root->left;
  root->left = root->right;
  root->right = temp;
}


𝐏𝐨𝐬𝐭𝐨𝐫𝐝𝐞𝐫 𝐓𝐫𝐚𝐯𝐞𝐫𝐬𝐚𝐥:
void postorder(struct Node* tree){
  if(root==NULL) return;
  postorder(root->left);
  postorder(root->right);
  cout<<root->data<<endl;
}

𝐏𝐫𝐞𝐨𝐫𝐝𝐞𝐫 𝐓𝐫𝐚𝐯𝐞𝐫𝐬𝐚𝐥:
void preorder(struct Node* root){
  if(root==NULL)return;
  preorder(root->left);
  cout<<root->data;
  preorder(root->right);
}

𝐂𝐡𝐞𝐜𝐤 𝐟𝐨𝐫 𝐁𝐒𝐓:
bool isBST(Node* node, int min,int max){
  if(node==NULL) return true;
  if(node->data < min || node->data > max) return false;
  return isBST(node->left,min,node->data-1) && isBST(node->right,node->data+1,max);
}
bool BST(Node* node){
int min = INT_MIN;
int max = INT_MAX;
 return isBST(node,min,max);
}

𝐋𝐞𝐯𝐞𝐥 𝐨𝐫𝐝𝐞𝐫 𝐭𝐫𝐚𝐯𝐞𝐫𝐬𝐚𝐥 𝐢𝐧 𝐬𝐩𝐢𝐫𝐚𝐥 𝐟𝐨𝐫𝐦:
void printSpiral(Node *root)
{
    if(root==NULL) return;
    int level=0;
    queue<Node* > q;
    q.push(root);
    while(!q.empty()){
        level++;
        vector<int> v;
        int s = q.size();
        while(s--){
            Node* temp = q.front();
            if(temp->left) q.push(temp->left);
            if(temp->right) q.push(temp->right);
            q.pop();
            v.push_back(temp->data);
        }
        if(level%2==1){
            reverse(v.begin(),v.end());
        }
        for(int i=0;i<v.size();i++){
                cout<<v[i]<<" ";
            }
    }
}
    
𝐓𝐫𝐚𝐧𝐬𝐟𝐨𝐫𝐦 𝐭𝐨 𝐒𝐮𝐦 𝐓𝐫𝐞𝐞:
int toSumTree(Node *Node)
    {
      if(Node==NULL) return 0;
      int old_value = Node->data;
      Node->data = toSumTree(Node->left)+toSumTree(Node->right);
      return Node->data + old_value;
    }

𝐂𝐡𝐞𝐜𝐤 𝐟𝐨𝐫 𝐁𝐚𝐥𝐚𝐧𝐜𝐞𝐝 𝐓𝐫𝐞𝐞:
int height(Node* root){
    if(root==NULL) return 0;
    int lheight = height(root->left);
    int rheight = height(root->right);
    return max(lheight,rheight)+1;
}
bool isBalanced(Node *root)
{
    if(root==NULL) return true;
    int l = height(root->left);
    int r = height(root->right);
    if(abs(l-r)<=1 && isBalanced(root->left) && isBalanced(root->right)){
        return true;
    }
    return false;
}

𝐙𝐢𝐠𝐙𝐚𝐠 𝐓𝐫𝐞𝐞 𝐓𝐫𝐚𝐯𝐞𝐫𝐬𝐚𝐥:
vector <int> zigZagTraversal(Node* root)
{
	vector<int> ans;
	if(root==NULL){
	    return ans;
	}
	queue<Node*> q;
	int level=0;
	q.push(root);
	while(!q.empty()){
	    int s = q.size();
	    vector<int> v;
	    while(s--){
	        Node* temp = q.front();
	        q.pop();
	        if(temp->left) {
	            q.push(temp->left);
	        }
	        if(temp->right){
	            q.push(temp->right);
	        }
	        v.push_back(temp->data);
	    }
	    if(level%2==0){
	        for(int i=0;i<v.size();i++){
	            ans.push_back(v[i]);
	        }
	    }
	    else{
	        for(int i=v.size()-1;i>=0;i--){
	            ans.push_back(v[i]);
	        }
	    }
	    level++;
	}
	return ans;
}

