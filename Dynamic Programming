ğğ®ğ¦ğ›ğğ« ğ¨ğŸ ğ”ğ§ğ¢ğªğ®ğ ğğšğ­ğ¡ğ¬
*Given a A X B matrix with your initial position at the top-left cell, find the number of possible unique paths to reach the bottom-right cell of the matrix from the initial position.
Note: Possible moves can be either down or right at any point in time, i.e., we can move to matrix[i+1][j] or matrix[i][j+1] from matrix[i][j].*

Sol :
int ans(int a,int b){
  int dp[a][b];
  for(int i=0;i<a;i++){
    dp[i][0]=1;
  }
  for(int i=0;i<b;i++){
    dp[0][i]=1;
  }
  for(int i=1;i<a;i++){
    for(int j=1;j<b;j++){
        dp[i][j]=dp[i-1][j]+dp[i][j-1];
  }}
  return dp[a-1][b-1];
}

ğ‚ğ¨ğ®ğ§ğ­ ğ°ğšğ²ğ¬ ğ­ğ¨ ğ«ğğšğœğ¡ ğ­ğ¡ğ ğ§â€™ğ­ğ¡ ğ¬ğ­ğšğ¢ğ«:
int countWaysUtil(int n, int m)
{
    int res[n];
    res[0] = 1;
    res[1] = 1;
    for(int i = 2; i < n; i++)
    {
       res[i] = 0;
       for(int j = 1; j <= m && j <= i; j++)
          res[i] += res[i - j];
    }
    return res[n - 1];
}
int countWays(int s, int m)
{
    return countWaysUtil(s + 1, m);
}

ğŒğšğ±ğ¢ğ¦ğ¢ğ³ğ ğ“ğ¡ğ ğ‚ğ®ğ­ ğ’ğğ ğ¦ğğ§ğ­ğ¬:
int maximizeTheCuts(int n, int x, int y, int z)
    {
        if(n==0) return 0;
        int one = (n-x)>0?maximizeTheCuts(n-x,x,y,z):0;
        int two = (n-y)>0?maximizeTheCuts(n-y,x,y,z):0;
        int three = (n-z)>0?maximizeTheCuts(n-z,x,y,z):0;
        return 1+max(one,max(two,three));
    }


